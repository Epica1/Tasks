Практическая работа №1.

Вариант №17.

Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу эмулятора как можно более похожей на работу в командной строке UNIX подобной ОС. 

Этап 1. REPL

Цель: создать минимальный прототип. Большинство функций в нем пока представляют собой заглушки, но диалог с пользователем уже поддерживается.

Требования: 
1. Приложение должно быть реализовано в форме консольного интерфейса(CLI). 
2. Приглашение к вводу должно формироваться на основе реальных данных ОС, в которой исполняется эмулятор. Пример: username@hostname:~$. 
3. Реализовать простой парсер, который разделяет ввод на команду и аргументы по пробелам. 
4. Реализовать команды-заглушки, которые выводят свое имя и аргументы: ls, cd. 
5. Реализовать команду exit. 
6. Продемонстрировать работу прототипа в интерактивном режиме. Необходимо показать примеры работы всей реализованной функциональности, включая обработку ошибок. 
7. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

Этап 2. Конфигурация

Цель: сделать эмулятор настраиваемым, то есть поддержать ввод параметров пользователя в приложение. Организовать для этого этапа отладочный вывод всех заданных параметров при запуске эмулятора.

Требования: 
1. Параметры командной строки: – Путь к физическому расположению VFS. – Путь к стартовому скрипту. 
2. Стартовый скрипт для выполнения команд эмулятора: выполняет команды последовательно, ошибочные строки пропускает. При выполнении скрипта на экране отображается как ввод, так и вывод, имитируя диалог с пользователем.
3. Реализовать вывод параметров эмулятора в формате ключ-значение с помощью служебной команды conf-dump. 
4. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. Включить в каждый скрипт вызовы эмулятора для тестирования всех поддерживаемых параметров командной строки. 
5. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом. 



Практическая работа №2.

Вариант №17.

Разработать инструмент визуализации графа зависимостей для менеджера пакетов. Готовые средства (менеджеры пакетов, библиотеки) для получения зависимостей использовать нельзя. 

Этап 1. Минимальный прототип с конфигурацией 

Цель: создать минимальное CLI-приложение и сделать его настраиваемым. 

Требования: 
1. Источником настраиваемых пользователем параметров являются опции командной строки.
2. К настраиваемым параметрам относятся:
   - Имя анализируемого пакета.
   - URL-адрес репозитория или путь к файлу тестового репозитория.
   - Режим работы с тестовым репозиторием.
   - Режим вывода зависимостей в формате ASCII-дерева. 
3. (только для этого этапа) При запуске приложения вывести все параметры, настраиваемые пользователем, в формате ключ-значение. 
4. Реализовать и продемонстрировать обработку ошибок для всех параметров. 
5. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом. 


Этап 2. Сбор данных 

Цель: реализовать основную логику получения данных о зависимостях для их дальнейшего анализа и визуализации. Запрещено пользоваться менеджерами пакетов и сторонними библиотеками для получения информации о зависимостях пакетов

Требования:
1. Использовать формат пакетов JavaScript (npm). 
2. Извлечь информацию о прямых зависимостях заданного пользователем пакета, используя URL-адрес репозитория. 
3. (только для этого этапа) Вывести на экран все прямые зависимости заданного пользователем пакета. 
4. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

Этап 3. Основные операции 

Цель: построить граф зависимостей (с учетом транзитивности) и выполнить основные операции над ним.

Требования:
1. Получение графа зависимостей реализовать алгоритмом DFS с рекурсией. 
2. Корректно обработать случаи наличия циклических зависимостей. 
3. Поддержать режим тестирования. Вместо URL реального репозитория, дать возможность пользователю указать путь к файлу описания графа репозитория, где пакеты называются большими латинскими буквами. 
Продемонстрировать функциональность этого этапа на различных случаях работы с тестовым репозиторием. 
4. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.



Практическая работа №3.

Вариант №17.

Поддерживаемые команды:

load_const - Загрузка константы на стек

Формат: REG[dest] = <константа>

Размер команды: 5 байт (40 бит)

Битовые поля:
- A (биты 0-5): код операции = 33 (6 бит)
- B (биты 6-33): константа (28 бит)
- C (биты 34-39): адрес регистра-назначения (6 бит)

Ограничения:
- Константа: от 0 до 268,435,455 (2²⁸-1)

read_mem - Чтение из памяти в регистр

Формат: REG[dest] = MEM[REG[base] + <смещение>]

Размер команды: 4 байта (32 бита)

Битовые поля:
- A (биты 0-5): код операции = 19 (6 бит)
- B (биты 6-11): адрес регистра-назначения (6 бит)
- C (биты 12-17): адрес базового регистра (6 бит)
- D (биты 18-31): смещение (14 бит)

Ограничения:
- Адреса регистров: от 0 до 63 (2⁶-1)

write_mem - Запись в память

Формат: MEM[<адрес>] = REG[src]

Размер команды: 5 байт (40 бит)

Битовые поля:
- A (биты 0-5): код операции = 58 (6 бит)
- B (биты 6-29): адрес памяти (24 бита)
- C (биты 30-35): адрес регистра-источника (6 бит)

Ограничения:
- Адрес памяти: от 0 до 16,777,215 (2²⁴-1)
- Адрес регистра: от 0 до 63 (2⁶-1)

abs - Абсолютное значение из памяти

Формат: REG[dest] = abs(MEM[REG[base]])

Размер команды: 3 байта (24 бита)

Битовые поля:

- A (биты 0-5): код операции = 26 (6 бит)
- B (биты 6-11): адрес регистра-назначения (6 бит)
- C (биты 12-17): адрес базового регистра (6 бит)

Ограничения:
- Адреса регистров: от 0 до 63 (2⁶-1)

Этап 1. Перевод программы в промежуточное представление

Цель: создать CLI-приложение ассемблера. Реализовать разбор текстового представления команд и трансляцию в промежуточное представление.

Требования:
1. Ассемблер должен принимать на вход аргументы командной строки:
– Путь к исходному файлу с текстом программы.
– Путь к двоичному файлу-результату.
– Режим тестирования. 
2. Спроектировать человекочитаемый язык ассемблера, используя “алгебраический” синтаксис в духе языков высокого уровня. Поддержать все команды спецификации УВМ. 
3. Описать в документации (например, в README.md) спроектированный язык ассемблера. 
4. Реализовать транслятор, который язык ассемблера преобразует во внутреннее представление (например, список кортежей, объектов или словарей). 
5. (только для данного этапа) В режиме тестирования вывести на экран внутреннее представление ассемблированной программы в формате полей и значений, как в тесте из спецификации УВМ. 
6. Создать программу для тестов, приведенных в спецификации УВМ. Продемонстрировать, что ассемблер генерирует идентичные последовательности полей и их значений. 
7. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

Этап 2. Формирование машинного кода

Цель: реализовать логику преобразования команд в их двоичное представление.

Требования: 
1. Реализовать транслятор из промежуточного в машинное представление.
2. Записать результат ассемблирования в двоичный выходной файл. 
3. Вывести на экран число ассемблированных команд. 
4. В режиме тестирования вывести результат ассемблирования на экран в байтовом формате, как в тесте из спецификации УВМ. 
5. Создать файл на языке ассемблера, результат трансляции которого соответствует всем тестовым байтовым последовательностям из спецификации УВМ. 
6. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом. 

